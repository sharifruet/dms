package com.bpdb.dms.service;

import com.bpdb.dms.entity.BackupRecord;
import com.bpdb.dms.entity.BackupStatus;
import com.bpdb.dms.entity.BackupType;
import com.bpdb.dms.repository.BackupRecordRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.zip.GZIPOutputStream;

/**
 * Service for disaster recovery and backup management
 */
@Service
@Transactional
public class DisasterRecoveryService {
    
    private static final Logger logger = LoggerFactory.getLogger(DisasterRecoveryService.class);
    
    @Autowired
    private BackupRecordRepository backupRecordRepository;
    
    @Autowired
    private AuditService auditService;
    
    @Value("${app.backup.enabled:true}")
    private boolean backupEnabled;
    
    @Value("${app.backup.schedule:cron:0 2 * * *}")
    private String backupSchedule;
    
    @Value("${app.backup.retention-days:30}")
    private int retentionDays;
    
    @Value("${app.backup.compression-enabled:true}")
    private boolean compressionEnabled;
    
    @Value("${app.backup.encryption-enabled:true}")
    private boolean encryptionEnabled;
    
    @Value("${app.backup.storage-path:/app/backups}")
    private String storagePath;
    
    /**
     * Create a full system backup
     */
    public CompletableFuture<BackupRecord> createFullBackup() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                logger.info("Starting full system backup");
                
                BackupRecord backupRecord = new BackupRecord();
                backupRecord.setBackupType(BackupType.FULL);
                backupRecord.setStatus(BackupStatus.IN_PROGRESS);
                backupRecord.setStartedAt(LocalDateTime.now());
                backupRecord.setBackupPath(generateBackupPath(BackupType.FULL));
                
                backupRecord = backupRecordRepository.save(backupRecord);
                
                // Create backup directory
                Path backupDir = Paths.get(backupRecord.getBackupPath());
                Files.createDirectories(backupDir);
                
                // Backup database
                backupDatabase(backupDir);
                
                // Backup file system
                backupFileSystem(backupDir);
                
                // Backup configuration
                backupConfiguration(backupDir);
                
                // Compress backup if enabled
                if (compressionEnabled) {
                    compressBackup(backupDir);
                }
                
                // Encrypt backup if enabled
                if (encryptionEnabled) {
                    encryptBackup(backupDir);
                }
                
                // Update backup record
                backupRecord.setStatus(BackupStatus.COMPLETED);
                backupRecord.setCompletedAt(LocalDateTime.now());
                backupRecord.setSizeBytes(calculateBackupSize(backupDir));
                backupRecord.setRetentionUntil(LocalDateTime.now().plusDays(retentionDays));
                
                backupRecord = backupRecordRepository.save(backupRecord);
                
                auditService.logActivity("SYSTEM", "BACKUP_CREATED", 
                    "Full backup created: " + backupRecord.getBackupPath(), null);
                
                logger.info("Full system backup completed: {}", backupRecord.getBackupPath());
                
                return backupRecord;
                
            } catch (Exception e) {
                logger.error("Failed to create full backup: {}", e.getMessage());
                throw new RuntimeException("Backup creation failed", e);
            }
        });
    }
    
    /**
     * Create an incremental backup
     */
    public CompletableFuture<BackupRecord> createIncrementalBackup() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                logger.info("Starting incremental backup");
                
                BackupRecord backupRecord = new BackupRecord();
                backupRecord.setBackupType(BackupType.INCREMENTAL);
                backupRecord.setStatus(BackupStatus.IN_PROGRESS);
                backupRecord.setStartedAt(LocalDateTime.now());
                backupRecord.setBackupPath(generateBackupPath(BackupType.INCREMENTAL));
                
                backupRecord = backupRecordRepository.save(backupRecord);
                
                // Create backup directory
                Path backupDir = Paths.get(backupRecord.getBackupPath());
                Files.createDirectories(backupDir);
                
                // Get last backup timestamp
                LocalDateTime lastBackupTime = getLastBackupTime();
                
                // Backup only changed files
                backupChangedFiles(backupDir, lastBackupTime);
                
                // Backup database changes
                backupDatabaseChanges(backupDir, lastBackupTime);
                
                // Compress backup if enabled
                if (compressionEnabled) {
                    compressBackup(backupDir);
                }
                
                // Update backup record
                backupRecord.setStatus(BackupStatus.COMPLETED);
                backupRecord.setCompletedAt(LocalDateTime.now());
                backupRecord.setSizeBytes(calculateBackupSize(backupDir));
                backupRecord.setRetentionUntil(LocalDateTime.now().plusDays(retentionDays));
                
                backupRecord = backupRecordRepository.save(backupRecord);
                
                auditService.logActivity("SYSTEM", "BACKUP_CREATED", 
                    "Incremental backup created: " + backupRecord.getBackupPath(), null);
                
                logger.info("Incremental backup completed: {}", backupRecord.getBackupPath());
                
                return backupRecord;
                
            } catch (Exception e) {
                logger.error("Failed to create incremental backup: {}", e.getMessage());
                throw new RuntimeException("Incremental backup creation failed", e);
            }
        });
    }
    
    /**
     * Restore from backup
     */
    public CompletableFuture<Map<String, Object>> restoreFromBackup(Long backupId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                logger.info("Starting restore from backup: {}", backupId);
                
                BackupRecord backupRecord = backupRecordRepository.findById(backupId)
                    .orElseThrow(() -> new RuntimeException("Backup not found"));
                
                if (backupRecord.getStatus() != BackupStatus.COMPLETED) {
                    throw new RuntimeException("Cannot restore from incomplete backup");
                }
                
                Path backupPath = Paths.get(backupRecord.getBackupPath());
                
                // Verify backup integrity
                verifyBackupIntegrity(backupPath);
                
                // Decrypt backup if encrypted
                if (encryptionEnabled) {
                    decryptBackup(backupPath);
                }
                
                // Decompress backup if compressed
                if (compressionEnabled) {
                    decompressBackup(backupPath);
                }
                
                // Restore database
                restoreDatabase(backupPath);
                
                // Restore file system
                restoreFileSystem(backupPath);
                
                // Restore configuration
                restoreConfiguration(backupPath);
                
                auditService.logActivity("SYSTEM", "BACKUP_RESTORED", 
                    "System restored from backup: " + backupRecord.getBackupPath(), null);
                
                logger.info("Restore completed successfully from backup: {}", backupRecord.getBackupPath());
                
                return Map.of(
                    "success", true,
                    "message", "Restore completed successfully",
                    "backupPath", backupRecord.getBackupPath(),
                    "restoredAt", LocalDateTime.now()
                );
                
            } catch (Exception e) {
                logger.error("Failed to restore from backup: {}", e.getMessage());
                throw new RuntimeException("Restore failed", e);
            }
        });
    }
    
    /**
     * Scheduled backup task
     */
    @Scheduled(cron = "${app.backup.schedule:cron:0 2 * * *}")
    public void scheduledBackup() {
        if (!backupEnabled) {
            logger.debug("Backup is disabled, skipping scheduled backup");
            return;
        }
        
        try {
            logger.info("Starting scheduled backup");
            
            // Check if we need a full backup (weekly)
            if (shouldCreateFullBackup()) {
                createFullBackup();
            } else {
                createIncrementalBackup();
            }
            
        } catch (Exception e) {
            logger.error("Scheduled backup failed: {}", e.getMessage());
        }
    }
    
    /**
     * Cleanup old backups
     */
    @Scheduled(fixedDelay = 86400000) // Run daily
    public void cleanupOldBackups() {
        try {
            logger.info("Starting backup cleanup");
            
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(retentionDays);
            List<BackupRecord> oldBackups = backupRecordRepository.findByRetentionUntilBefore(cutoffDate);
            
            for (BackupRecord backup : oldBackups) {
                try {
                    // Delete backup files
                    Path backupPath = Paths.get(backup.getBackupPath());
                    if (Files.exists(backupPath)) {
                        deleteDirectory(backupPath);
                    }
                    
                    // Delete backup record
                    backupRecordRepository.delete(backup);
                    
                    auditService.logActivity("SYSTEM", "BACKUP_CLEANUP", 
                        "Old backup deleted: " + backup.getBackupPath(), null);
                    
                    logger.info("Deleted old backup: {}", backup.getBackupPath());
                    
                } catch (Exception e) {
                    logger.error("Failed to delete backup {}: {}", backup.getId(), e.getMessage());
                }
            }
            
        } catch (Exception e) {
            logger.error("Backup cleanup failed: {}", e.getMessage());
        }
    }
    
    /**
     * Get backup statistics
     */
    public Map<String, Object> getBackupStatistics() {
        try {
            return Map.of(
                "totalBackups", backupRecordRepository.count(),
                "completedBackups", backupRecordRepository.countByStatus(BackupStatus.COMPLETED),
                "failedBackups", backupRecordRepository.countByStatus(BackupStatus.FAILED),
                "inProgressBackups", backupRecordRepository.countByStatus(BackupStatus.IN_PROGRESS),
                "totalSizeBytes", backupRecordRepository.sumSizeBytes(),
                "lastBackupDate", getLastBackupTime(),
                "nextScheduledBackup", getNextScheduledBackupTime()
            );
            
        } catch (Exception e) {
            logger.error("Failed to get backup statistics: {}", e.getMessage());
            throw new RuntimeException("Failed to get backup statistics", e);
        }
    }
    
    /**
     * Test backup integrity
     */
    public Map<String, Object> testBackupIntegrity(Long backupId) {
        try {
            BackupRecord backupRecord = backupRecordRepository.findById(backupId)
                .orElseThrow(() -> new RuntimeException("Backup not found"));
            
            Path backupPath = Paths.get(backupRecord.getBackupPath());
            
            boolean integrityCheck = verifyBackupIntegrity(backupPath);
            
            return Map.of(
                "backupId", backupId,
                "integrityCheck", integrityCheck,
                "testedAt", LocalDateTime.now(),
                "message", integrityCheck ? "Backup integrity verified" : "Backup integrity failed"
            );
            
        } catch (Exception e) {
            logger.error("Backup integrity test failed: {}", e.getMessage());
            return Map.of(
                "backupId", backupId,
                "integrityCheck", false,
                "testedAt", LocalDateTime.now(),
                "message", "Integrity test failed: " + e.getMessage()
            );
        }
    }
    
    // Private helper methods
    
    private String generateBackupPath(BackupType type) {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        return storagePath + "/" + type.name().toLowerCase() + "_" + timestamp;
    }
    
    private void backupDatabase(Path backupDir) throws IOException {
        // Simulate database backup
        Path dbBackupFile = backupDir.resolve("database.sql");
        Files.write(dbBackupFile, "Database backup content".getBytes());
        logger.info("Database backup created: {}", dbBackupFile);
    }
    
    private void backupFileSystem(Path backupDir) throws IOException {
        // Simulate file system backup
        Path fsBackupDir = backupDir.resolve("filesystem");
        Files.createDirectories(fsBackupDir);
        
        // Copy uploads directory
        Path uploadsDir = Paths.get("/app/uploads");
        if (Files.exists(uploadsDir)) {
            copyDirectory(uploadsDir, fsBackupDir.resolve("uploads"));
        }
        
        logger.info("File system backup created: {}", fsBackupDir);
    }
    
    private void backupConfiguration(Path backupDir) throws IOException {
        // Simulate configuration backup
        Path configFile = backupDir.resolve("application.properties");
        Files.write(configFile, "Configuration backup content".getBytes());
        logger.info("Configuration backup created: {}", configFile);
    }
    
    private void backupChangedFiles(Path backupDir, LocalDateTime lastBackupTime) throws IOException {
        // Simulate incremental file backup
        Path incrementalDir = backupDir.resolve("incremental");
        Files.createDirectories(incrementalDir);
        
        // This would normally check file modification times
        logger.info("Incremental file backup created: {}", incrementalDir);
    }
    
    private void backupDatabaseChanges(Path backupDir, LocalDateTime lastBackupTime) throws IOException {
        // Simulate incremental database backup
        Path dbChangesFile = backupDir.resolve("database_changes.sql");
        Files.write(dbChangesFile, "Database changes since last backup".getBytes());
        logger.info("Database changes backup created: {}", dbChangesFile);
    }
    
    private void compressBackup(Path backupDir) throws IOException {
        // Simulate backup compression
        logger.info("Backup compressed: {}", backupDir);
    }
    
    private void encryptBackup(Path backupDir) throws IOException {
        // Simulate backup encryption
        logger.info("Backup encrypted: {}", backupDir);
    }
    
    private void verifyBackupIntegrity(Path backupPath) throws IOException {
        // Simulate backup integrity verification
        if (!Files.exists(backupPath)) {
            throw new IOException("Backup path does not exist");
        }
        logger.info("Backup integrity verified: {}", backupPath);
    }
    
    private void decryptBackup(Path backupPath) throws IOException {
        // Simulate backup decryption
        logger.info("Backup decrypted: {}", backupPath);
    }
    
    private void decompressBackup(Path backupPath) throws IOException {
        // Simulate backup decompression
        logger.info("Backup decompressed: {}", backupPath);
    }
    
    private void restoreDatabase(Path backupPath) throws IOException {
        // Simulate database restore
        logger.info("Database restored from: {}", backupPath);
    }
    
    private void restoreFileSystem(Path backupPath) throws IOException {
        // Simulate file system restore
        logger.info("File system restored from: {}", backupPath);
    }
    
    private void restoreConfiguration(Path backupPath) throws IOException {
        // Simulate configuration restore
        logger.info("Configuration restored from: {}", backupPath);
    }
    
    private long calculateBackupSize(Path backupDir) {
        try {
            return Files.walk(backupDir)
                .filter(Files::isRegularFile)
                .mapToLong(path -> {
                    try {
                        return Files.size(path);
                    } catch (IOException e) {
                        return 0L;
                    }
                })
                .sum();
        } catch (IOException e) {
            return 0L;
        }
    }
    
    private LocalDateTime getLastBackupTime() {
        return backupRecordRepository.findTopByStatusOrderByCompletedAtDesc(BackupStatus.COMPLETED)
            .map(BackupRecord::getCompletedAt)
            .orElse(LocalDateTime.now().minusDays(1));
    }
    
    private LocalDateTime getNextScheduledBackupTime() {
        // This would normally parse the cron expression
        return LocalDateTime.now().plusHours(24);
    }
    
    private boolean shouldCreateFullBackup() {
        LocalDateTime lastFullBackup = backupRecordRepository
            .findTopByBackupTypeAndStatusOrderByCompletedAtDesc(BackupType.FULL, BackupStatus.COMPLETED)
            .map(BackupRecord::getCompletedAt)
            .orElse(LocalDateTime.now().minusDays(8));
        
        return lastFullBackup.isBefore(LocalDateTime.now().minusDays(7));
    }
    
    private void copyDirectory(Path source, Path target) throws IOException {
        Files.walk(source)
            .forEach(sourcePath -> {
                try {
                    Path targetPath = target.resolve(source.relativize(sourcePath));
                    if (Files.isDirectory(sourcePath)) {
                        Files.createDirectories(targetPath);
                    } else {
                        Files.copy(sourcePath, targetPath);
                    }
                } catch (IOException e) {
                    logger.error("Failed to copy file: {}", e.getMessage());
                }
            });
    }
    
    private void deleteDirectory(Path directory) throws IOException {
        Files.walk(directory)
            .sorted((a, b) -> b.compareTo(a)) // Delete files before directories
            .forEach(path -> {
                try {
                    Files.delete(path);
                } catch (IOException e) {
                    logger.error("Failed to delete file: {}", e.getMessage());
                }
            });
    }
}
