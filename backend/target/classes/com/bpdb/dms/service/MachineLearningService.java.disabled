package com.bpdb.dms.service;

import com.bpdb.dms.entity.*;
import com.bpdb.dms.repository.MLModelRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;

/**
 * Service for machine learning capabilities
 */
@Service
@Transactional
public class MachineLearningService {
    
    private static final Logger logger = LoggerFactory.getLogger(MachineLearningService.class);
    
    @Autowired
    private MLModelRepository mlModelRepository;
    
    @Autowired
    private AuditService auditService;
    
    @Autowired
    private AdvancedAnalyticsService analyticsService;
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    /**
     * Create a new ML model
     */
    public MLModel createMLModel(String name, String description, ModelType modelType, 
                                String version, String modelConfig, User createdBy) {
        try {
            MLModel model = new MLModel(name, description, modelType, version, createdBy);
            model.setModelConfig(modelConfig);
            model.setStatus(ModelStatus.TRAINING);
            model.setTrainingStartedAt(LocalDateTime.now());
            
            MLModel savedModel = mlModelRepository.save(model);
            
            auditService.logActivity(createdBy.getUsername(), "ML_MODEL_CREATED", 
                "ML model created: " + name, null);
            
            logger.info("ML model created: {} by user: {}", name, createdBy.getUsername());
            
            return savedModel;
            
        } catch (Exception e) {
            logger.error("Failed to create ML model: {}", e.getMessage());
            throw new RuntimeException("Failed to create ML model", e);
        }
    }
    
    /**
     * Train ML model
     */
    @Async
    public CompletableFuture<MLModel> trainMLModel(Long modelId, String trainingDataPath) {
        try {
            MLModel model = mlModelRepository.findById(modelId)
                .orElseThrow(() -> new RuntimeException("ML model not found"));
            
            logger.info("Starting training for ML model: {}", model.getName());
            
            // Update model status
            model.setStatus(ModelStatus.TRAINING);
            model.setTrainingStartedAt(LocalDateTime.now());
            model.setTrainingDataPath(trainingDataPath);
            mlModelRepository.save(model);
            
            // Simulate training process (in production, this would call actual ML framework)
            boolean trainingSuccess = performModelTraining(model, trainingDataPath);
            
            if (trainingSuccess) {
                // Update model with training results
                model.setStatus(ModelStatus.TRAINED);
                model.setTrainingCompletedAt(LocalDateTime.now());
                model.setAccuracyScore(0.85); // Simulated accuracy
                model.setPrecisionScore(0.82);
                model.setRecallScore(0.88);
                model.setF1Score(0.85);
                
                // Set performance metrics
                Map<String, Object> metrics = Map.of(
                    "accuracy", 0.85,
                    "precision", 0.82,
                    "recall", 0.88,
                    "f1_score", 0.85,
                    "training_time", "2.5 hours",
                    "data_size", "10,000 samples"
                );
                model.setPerformanceMetrics(objectMapper.writeValueAsString(metrics));
                
                mlModelRepository.save(model);
                
                logger.info("ML model training completed: {} - Accuracy: {}", 
                    model.getName(), model.getAccuracyScore());
                
                return CompletableFuture.completedFuture(model);
                
            } else {
                model.setStatus(ModelStatus.FAILED);
                mlModelRepository.save(model);
                
                logger.error("ML model training failed: {}", model.getName());
                return CompletableFuture.failedFuture(new RuntimeException("Training failed"));
            }
            
        } catch (Exception e) {
            logger.error("Failed to train ML model: {}", e.getMessage());
            return CompletableFuture.failedFuture(e);
        }
    }
    
    /**
     * Deploy ML model
     */
    public MLModel deployMLModel(Long modelId, User deployedBy) {
        try {
            MLModel model = mlModelRepository.findById(modelId)
                .orElseThrow(() -> new RuntimeException("ML model not found"));
            
            if (model.getStatus() != ModelStatus.TRAINED) {
                throw new RuntimeException("Model must be trained before deployment");
            }
            
            // Deactivate other models of the same type
            deactivateOtherModels(model.getModelType());
            
            // Deploy the model
            model.setStatus(ModelStatus.DEPLOYED);
            model.setIsActive(true);
            model.setLastModifiedBy(deployedBy);
            
            MLModel savedModel = mlModelRepository.save(model);
            
            auditService.logActivity(deployedBy.getUsername(), "ML_MODEL_DEPLOYED", 
                "ML model deployed: " + model.getName(), null);
            
            logger.info("ML model deployed: {}", model.getName());
            
            return savedModel;
            
        } catch (Exception e) {
            logger.error("Failed to deploy ML model: {}", e.getMessage());
            throw new RuntimeException("Failed to deploy ML model", e);
        }
    }
    
    /**
     * Make prediction using ML model
     */
    public Map<String, Object> makePrediction(Long modelId, Map<String, Object> inputData) {
        try {
            MLModel model = mlModelRepository.findById(modelId)
                .orElseThrow(() -> new RuntimeException("ML model not found"));
            
            if (!model.getIsActive()) {
                throw new RuntimeException("Model is not active");
            }
            
            // Perform prediction based on model type
            Map<String, Object> prediction = performPrediction(model, inputData);
            
            // Update prediction statistics
            model.setLastPredictionAt(LocalDateTime.now());
            model.setPredictionCount(model.getPredictionCount() + 1);
            mlModelRepository.save(model);
            
            // Collect analytics data
            analyticsService.collectAnalyticsData(
                AnalyticsType.PREDICTIVE_ANALYTICS,
                "prediction_made",
                1.0,
                Map.of("modelId", modelId, "modelType", model.getModelType().name()),
                "ML_SERVICE",
                null,
                null
            );
            
            logger.info("Prediction made using model: {} - Confidence: {}", 
                model.getName(), prediction.get("confidence"));
            
            return prediction;
            
        } catch (Exception e) {
            logger.error("Failed to make prediction: {}", e.getMessage());
            throw new RuntimeException("Failed to make prediction", e);
        }
    }
    
    /**
     * Retrain ML model
     */
    @Async
    public CompletableFuture<MLModel> retrainMLModel(Long modelId) {
        try {
            MLModel model = mlModelRepository.findById(modelId)
                .orElseThrow(() -> new RuntimeException("ML model not found"));
            
            logger.info("Starting retraining for ML model: {}", model.getName());
            
            model.setStatus(ModelStatus.RETRAINING);
            model.setTrainingStartedAt(LocalDateTime.now());
            mlModelRepository.save(model);
            
            // Perform retraining
            boolean retrainingSuccess = performModelRetraining(model);
            
            if (retrainingSuccess) {
                model.setStatus(ModelStatus.TRAINED);
                model.setTrainingCompletedAt(LocalDateTime.now());
                model.setNextRetrainAt(LocalDateTime.now().plusDays(model.getRetrainFrequencyDays()));
                
                // Update performance metrics
                model.setAccuracyScore(model.getAccuracyScore() + 0.02); // Simulated improvement
                
                mlModelRepository.save(model);
                
                logger.info("ML model retraining completed: {}", model.getName());
                
                return CompletableFuture.completedFuture(model);
                
            } else {
                model.setStatus(ModelStatus.FAILED);
                mlModelRepository.save(model);
                
                logger.error("ML model retraining failed: {}", model.getName());
                return CompletableFuture.failedFuture(new RuntimeException("Retraining failed"));
            }
            
        } catch (Exception e) {
            logger.error("Failed to retrain ML model: {}", e.getMessage());
            return CompletableFuture.failedFuture(e);
        }
    }
    
    /**
     * Process automatic retraining
     */
    @Async
    public void processAutomaticRetraining() {
        try {
            List<MLModel> modelsDueForRetraining = mlModelRepository.findMLModelsDueForRetraining(LocalDateTime.now());
            
            for (MLModel model : modelsDueForRetraining) {
                retrainMLModel(model.getId());
            }
            
        } catch (Exception e) {
            logger.error("Failed to process automatic retraining: {}", e.getMessage());
        }
    }
    
    /**
     * Get ML model statistics
     */
    public Map<String, Object> getMLModelStatistics() {
        try {
            return Map.of(
                "totalModels", mlModelRepository.count(),
                "activeModels", mlModelRepository.countByIsActiveTrue(),
                "trainedModels", mlModelRepository.countByStatus(ModelStatus.TRAINED),
                "deployedModels", mlModelRepository.countByStatus(ModelStatus.DEPLOYED),
                "failedModels", mlModelRepository.countByStatus(ModelStatus.FAILED)
            );
            
        } catch (Exception e) {
            logger.error("Failed to get ML model statistics: {}", e.getMessage());
            throw new RuntimeException("Failed to get ML model statistics", e);
        }
    }
    
    /**
     * Get best performing models
     */
    public List<MLModel> getBestPerformingModels(int limit) {
        return mlModelRepository.findBestPerformingModels(Pageable.ofSize(limit));
    }
    
    /**
     * Get models by type
     */
    public Page<MLModel> getModelsByType(ModelType modelType, Pageable pageable) {
        return mlModelRepository.findByModelType(modelType, pageable);
    }
    
    /**
     * Get models for user
     */
    public Page<MLModel> getModelsForUser(User user, Pageable pageable) {
        return mlModelRepository.findByCreatedBy(user, pageable);
    }
    
    /**
     * Perform model training
     */
    private boolean performModelTraining(MLModel model, String trainingDataPath) {
        try {
            // Simulate training process
            Thread.sleep(2000); // Simulate training time
            
            // In production, this would:
            // 1. Load training data from the specified path
            // 2. Preprocess the data
            // 3. Train the model using appropriate ML framework (TensorFlow, PyTorch, etc.)
            // 4. Evaluate the model
            // 5. Save the trained model
            
            logger.info("Model training completed for: {}", model.getName());
            return true;
            
        } catch (Exception e) {
            logger.error("Model training failed: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Perform model retraining
     */
    private boolean performModelRetraining(MLModel model) {
        try {
            // Simulate retraining process
            Thread.sleep(1500); // Simulate retraining time
            
            logger.info("Model retraining completed for: {}", model.getName());
            return true;
            
        } catch (Exception e) {
            logger.error("Model retraining failed: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Perform prediction
     */
    private Map<String, Object> performPrediction(MLModel model, Map<String, Object> inputData) {
        try {
            // Simulate prediction based on model type
            Map<String, Object> prediction = new HashMap<>();
            
            switch (model.getModelType()) {
                case DOCUMENT_CLASSIFICATION:
                    prediction = performDocumentClassification(inputData);
                    break;
                case SENTIMENT_ANALYSIS:
                    prediction = performSentimentAnalysis(inputData);
                    break;
                case TEXT_EXTRACTION:
                    prediction = performTextExtraction(inputData);
                    break;
                case ANOMALY_DETECTION:
                    prediction = performAnomalyDetection(inputData);
                    break;
                case RECOMMENDATION_ENGINE:
                    prediction = performRecommendation(inputData);
                    break;
                default:
                    prediction = performGenericPrediction(inputData);
            }
            
            return prediction;
            
        } catch (Exception e) {
            logger.error("Prediction failed: {}", e.getMessage());
            throw new RuntimeException("Prediction failed", e);
        }
    }
    
    /**
     * Perform document classification
     */
    private Map<String, Object> performDocumentClassification(Map<String, Object> inputData) {
        return Map.of(
            "predictedClass", "Contract",
            "confidence", 0.92,
            "probabilities", Map.of(
                "Contract", 0.92,
                "Report", 0.05,
                "Letter", 0.03
            )
        );
    }
    
    /**
     * Perform sentiment analysis
     */
    private Map<String, Object> performSentimentAnalysis(Map<String, Object> inputData) {
        return Map.of(
            "sentiment", "Positive",
            "confidence", 0.87,
            "scores", Map.of(
                "Positive", 0.87,
                "Neutral", 0.10,
                "Negative", 0.03
            )
        );
    }
    
    /**
     * Perform text extraction
     */
    private Map<String, Object> performTextExtraction(Map<String, Object> inputData) {
        return Map.of(
            "extractedText", "Sample extracted text from document",
            "confidence", 0.95,
            "entities", List.of(
                Map.of("type", "PERSON", "value", "John Doe"),
                Map.of("type", "ORGANIZATION", "value", "ABC Corp")
            )
        );
    }
    
    /**
     * Perform anomaly detection
     */
    private Map<String, Object> performAnomalyDetection(Map<String, Object> inputData) {
        return Map.of(
            "isAnomaly", false,
            "anomalyScore", 0.15,
            "confidence", 0.89,
            "explanation", "Normal pattern detected"
        );
    }
    
    /**
     * Perform recommendation
     */
    private Map<String, Object> performRecommendation(Map<String, Object> inputData) {
        return Map.of(
            "recommendations", List.of(
                Map.of("item", "Document A", "score", 0.95),
                Map.of("item", "Document B", "score", 0.87),
                Map.of("item", "Document C", "score", 0.82)
            ),
            "confidence", 0.91
        );
    }
    
    /**
     * Perform generic prediction
     */
    private Map<String, Object> performGenericPrediction(Map<String, Object> inputData) {
        return Map.of(
            "prediction", "Generic prediction result",
            "confidence", 0.75,
            "metadata", Map.of("modelType", "Generic")
        );
    }
    
    /**
     * Deactivate other models of the same type
     */
    private void deactivateOtherModels(ModelType modelType) {
        try {
            List<MLModel> otherModels = mlModelRepository.findByModelType(modelType)
                .getContent()
                .stream()
                .filter(model -> model.getIsActive())
                .collect(java.util.stream.Collectors.toList());
            
            for (MLModel model : otherModels) {
                model.setIsActive(false);
                mlModelRepository.save(model);
            }
            
        } catch (Exception e) {
            logger.error("Failed to deactivate other models: {}", e.getMessage());
        }
    }
}
