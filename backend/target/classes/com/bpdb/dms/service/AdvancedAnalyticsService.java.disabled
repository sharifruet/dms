package com.bpdb.dms.service;

import com.bpdb.dms.entity.*;
import com.bpdb.dms.repository.AnalyticsDataRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Service for advanced analytics and business intelligence
 */
@Service
@Transactional
public class AdvancedAnalyticsService {
    
    private static final Logger logger = LoggerFactory.getLogger(AdvancedAnalyticsService.class);
    
    @Autowired
    private AnalyticsDataRepository analyticsDataRepository;
    
    @Autowired
    private AuditService auditService;
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    /**
     * Collect analytics data
     */
    public void collectAnalyticsData(AnalyticsType analyticsType, String metricName, 
                                   Double metricValue, Map<String, Object> dimensions,
                                   String sourceSystem, Long userId, Long documentId) {
        try {
            AnalyticsData analyticsData = new AnalyticsData(analyticsType, metricName, metricValue, LocalDateTime.now());
            analyticsData.setSourceSystem(sourceSystem);
            analyticsData.setUserId(userId);
            analyticsData.setDocumentId(documentId);
            
            if (dimensions != null && !dimensions.isEmpty()) {
                analyticsData.setDimensions(objectMapper.writeValueAsString(dimensions));
            }
            
            analyticsDataRepository.save(analyticsData);
            
            logger.debug("Analytics data collected: {} - {}", metricName, metricValue);
            
        } catch (Exception e) {
            logger.error("Failed to collect analytics data: {}", e.getMessage());
        }
    }
    
    /**
     * Get analytics dashboard data
     */
    public Map<String, Object> getAnalyticsDashboard(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            Map<String, Object> dashboard = new HashMap<>();
            
            // User activity metrics
            dashboard.put("userActivity", getUserActivityMetrics(startDate, endDate));
            
            // Document usage metrics
            dashboard.put("documentUsage", getDocumentUsageMetrics(startDate, endDate));
            
            // System performance metrics
            dashboard.put("systemPerformance", getSystemPerformanceMetrics(startDate, endDate));
            
            // Workflow metrics
            dashboard.put("workflowMetrics", getWorkflowMetrics(startDate, endDate));
            
            // Search analytics
            dashboard.put("searchAnalytics", getSearchAnalytics(startDate, endDate));
            
            // Storage metrics
            dashboard.put("storageMetrics", getStorageMetrics(startDate, endDate));
            
            // Security events
            dashboard.put("securityEvents", getSecurityEvents(startDate, endDate));
            
            return dashboard;
            
        } catch (Exception e) {
            logger.error("Failed to get analytics dashboard: {}", e.getMessage());
            throw new RuntimeException("Failed to get analytics dashboard", e);
        }
    }
    
    /**
     * Get user activity metrics
     */
    public Map<String, Object> getUserActivityMetrics(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            List<AnalyticsData> userActivityData = analyticsDataRepository.findByTimestampBetween(startDate, endDate)
                .stream()
                .filter(data -> data.getAnalyticsType() == AnalyticsType.USER_ACTIVITY)
                .collect(Collectors.toList());
            
            Map<String, Object> metrics = new HashMap<>();
            metrics.put("totalUsers", userActivityData.stream().mapToLong(AnalyticsData::getUserId).distinct().count());
            metrics.put("activeUsers", userActivityData.stream().mapToLong(AnalyticsData::getUserId).distinct().count());
            metrics.put("totalSessions", userActivityData.size());
            metrics.put("averageSessionDuration", calculateAverageSessionDuration(userActivityData));
            metrics.put("peakUsageHours", calculatePeakUsageHours(userActivityData));
            
            return metrics;
            
        } catch (Exception e) {
            logger.error("Failed to get user activity metrics: {}", e.getMessage());
            return Map.of();
        }
    }
    
    /**
     * Get document usage metrics
     */
    public Map<String, Object> getDocumentUsageMetrics(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            List<AnalyticsData> documentUsageData = analyticsDataRepository.findByTimestampBetween(startDate, endDate)
                .stream()
                .filter(data -> data.getAnalyticsType() == AnalyticsType.DOCUMENT_USAGE)
                .collect(Collectors.toList());
            
            Map<String, Object> metrics = new HashMap<>();
            metrics.put("totalDocuments", documentUsageData.stream().mapToLong(AnalyticsData::getDocumentId).distinct().count());
            metrics.put("totalDownloads", documentUsageData.stream().mapToLong(data -> data.getMetricValue().longValue()).sum());
            metrics.put("averageDownloadsPerDocument", calculateAverageDownloadsPerDocument(documentUsageData));
            metrics.put("mostAccessedDocuments", getMostAccessedDocuments(documentUsageData));
            metrics.put("documentTypesDistribution", getDocumentTypesDistribution(documentUsageData));
            
            return metrics;
            
        } catch (Exception e) {
            logger.error("Failed to get document usage metrics: {}", e.getMessage());
            return Map.of();
        }
    }
    
    /**
     * Get system performance metrics
     */
    public Map<String, Object> getSystemPerformanceMetrics(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            List<AnalyticsData> performanceData = analyticsDataRepository.findByTimestampBetween(startDate, endDate)
                .stream()
                .filter(data -> data.getAnalyticsType() == AnalyticsType.SYSTEM_PERFORMANCE)
                .collect(Collectors.toList());
            
            Map<String, Object> metrics = new HashMap<>();
            metrics.put("averageResponseTime", calculateAverageResponseTime(performanceData));
            metrics.put("peakResponseTime", calculatePeakResponseTime(performanceData));
            metrics.put("errorRate", calculateErrorRate(performanceData));
            metrics.put("throughput", calculateThroughput(performanceData));
            metrics.put("uptime", calculateUptime(performanceData));
            
            return metrics;
            
        } catch (Exception e) {
            logger.error("Failed to get system performance metrics: {}", e.getMessage());
            return Map.of();
        }
    }
    
    /**
     * Get workflow metrics
     */
    public Map<String, Object> getWorkflowMetrics(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            List<AnalyticsData> workflowData = analyticsDataRepository.findByTimestampBetween(startDate, endDate)
                .stream()
                .filter(data -> data.getAnalyticsType() == AnalyticsType.WORKFLOW_METRICS)
                .collect(Collectors.toList());
            
            Map<String, Object> metrics = new HashMap<>();
            metrics.put("totalWorkflows", workflowData.size());
            metrics.put("completedWorkflows", calculateCompletedWorkflows(workflowData));
            metrics.put("averageCompletionTime", calculateAverageCompletionTime(workflowData));
            metrics.put("workflowEfficiency", calculateWorkflowEfficiency(workflowData));
            metrics.put("bottlenecks", identifyWorkflowBottlenecks(workflowData));
            
            return metrics;
            
        } catch (Exception e) {
            logger.error("Failed to get workflow metrics: {}", e.getMessage());
            return Map.of();
        }
    }
    
    /**
     * Get search analytics
     */
    public Map<String, Object> getSearchAnalytics(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            List<AnalyticsData> searchData = analyticsDataRepository.findByTimestampBetween(startDate, endDate)
                .stream()
                .filter(data -> data.getAnalyticsType() == AnalyticsType.SEARCH_ANALYTICS)
                .collect(Collectors.toList());
            
            Map<String, Object> metrics = new HashMap<>();
            metrics.put("totalSearches", searchData.size());
            metrics.put("averageSearchTime", calculateAverageSearchTime(searchData));
            metrics.put("popularSearchTerms", getPopularSearchTerms(searchData));
            metrics.put("searchSuccessRate", calculateSearchSuccessRate(searchData));
            metrics.put("noResultsSearches", calculateNoResultsSearches(searchData));
            
            return metrics;
            
        } catch (Exception e) {
            logger.error("Failed to get search analytics: {}", e.getMessage());
            return Map.of();
        }
    }
    
    /**
     * Get storage metrics
     */
    public Map<String, Object> getStorageMetrics(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            List<AnalyticsData> storageData = analyticsDataRepository.findByTimestampBetween(startDate, endDate)
                .stream()
                .filter(data -> data.getAnalyticsType() == AnalyticsType.STORAGE_METRICS)
                .collect(Collectors.toList());
            
            Map<String, Object> metrics = new HashMap<>();
            metrics.put("totalStorageUsed", calculateTotalStorageUsed(storageData));
            metrics.put("storageGrowthRate", calculateStorageGrowthRate(storageData));
            metrics.put("averageFileSize", calculateAverageFileSize(storageData));
            metrics.put("storageByType", getStorageByType(storageData));
            metrics.put("cleanupRecommendations", getCleanupRecommendations(storageData));
            
            return metrics;
            
        } catch (Exception e) {
            logger.error("Failed to get storage metrics: {}", e.getMessage());
            return Map.of();
        }
    }
    
    /**
     * Get security events
     */
    public Map<String, Object> getSecurityEvents(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            List<AnalyticsData> securityData = analyticsDataRepository.findByTimestampBetween(startDate, endDate)
                .stream()
                .filter(data -> data.getAnalyticsType() == AnalyticsType.SECURITY_EVENTS)
                .collect(Collectors.toList());
            
            Map<String, Object> metrics = new HashMap<>();
            metrics.put("totalSecurityEvents", securityData.size());
            metrics.put("failedLoginAttempts", calculateFailedLoginAttempts(securityData));
            metrics.put("suspiciousActivities", calculateSuspiciousActivities(securityData));
            metrics.put("securityAlerts", getSecurityAlerts(securityData));
            metrics.put("complianceScore", calculateComplianceScore(securityData));
            
            return metrics;
            
        } catch (Exception e) {
            logger.error("Failed to get security events: {}", e.getMessage());
            return Map.of();
        }
    }
    
    /**
     * Generate predictive analytics
     */
    @Async
    public CompletableFuture<Map<String, Object>> generatePredictiveAnalytics() {
        try {
            Map<String, Object> predictions = new HashMap<>();
            
            // Predict user activity trends
            predictions.put("userActivityPrediction", predictUserActivityTrends());
            
            // Predict storage growth
            predictions.put("storageGrowthPrediction", predictStorageGrowth());
            
            // Predict system load
            predictions.put("systemLoadPrediction", predictSystemLoad());
            
            // Predict document usage patterns
            predictions.put("documentUsagePrediction", predictDocumentUsagePatterns());
            
            // Predict workflow completion times
            predictions.put("workflowCompletionPrediction", predictWorkflowCompletionTimes());
            
            logger.info("Predictive analytics generated successfully");
            
            return CompletableFuture.completedFuture(predictions);
            
        } catch (Exception e) {
            logger.error("Failed to generate predictive analytics: {}", e.getMessage());
            return CompletableFuture.failedFuture(e);
        }
    }
    
    /**
     * Get analytics data by criteria
     */
    public Page<AnalyticsData> getAnalyticsData(AnalyticsType analyticsType, String metricName,
                                               Long userId, Long documentId, String department,
                                               Boolean isPredicted, Pageable pageable) {
        return analyticsDataRepository.findByMultipleCriteria(
            analyticsType, metricName, userId, documentId, department, isPredicted, pageable);
    }
    
    /**
     * Get aggregated metrics
     */
    public List<Object[]> getAggregatedMetrics(LocalDateTime startDate, LocalDateTime endDate) {
        return analyticsDataRepository.getAggregatedMetricsByTimeRange(startDate, endDate);
    }
    
    // Helper methods for calculations
    
    private Double calculateAverageSessionDuration(List<AnalyticsData> data) {
        return data.stream()
            .mapToDouble(AnalyticsData::getMetricValue)
            .average()
            .orElse(0.0);
    }
    
    private List<Integer> calculatePeakUsageHours(List<AnalyticsData> data) {
        Map<Integer, Long> hourCounts = data.stream()
            .collect(Collectors.groupingBy(
                d -> d.getTimestamp().getHour(),
                Collectors.counting()
            ));
        
        return hourCounts.entrySet().stream()
            .sorted(Map.Entry.<Integer, Long>comparingByValue().reversed())
            .limit(3)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }
    
    private Double calculateAverageDownloadsPerDocument(List<AnalyticsData> data) {
        Map<Long, Long> documentDownloads = data.stream()
            .collect(Collectors.groupingBy(
                AnalyticsData::getDocumentId,
                Collectors.counting()
            ));
        
        return documentDownloads.values().stream()
            .mapToLong(Long::longValue)
            .average()
            .orElse(0.0);
    }
    
    private List<Map<String, Object>> getMostAccessedDocuments(List<AnalyticsData> data) {
        Map<Long, Long> documentCounts = data.stream()
            .collect(Collectors.groupingBy(
                AnalyticsData::getDocumentId,
                Collectors.counting()
            ));
        
        return documentCounts.entrySet().stream()
            .sorted(Map.Entry.<Long, Long>comparingByValue().reversed())
            .limit(10)
            .map(entry -> Map.of(
                "documentId", entry.getKey(),
                "accessCount", entry.getValue()
            ))
            .collect(Collectors.toList());
    }
    
    private Map<String, Long> getDocumentTypesDistribution(List<AnalyticsData> data) {
        // This would need to be implemented based on actual document type data
        return Map.of();
    }
    
    private Double calculateAverageResponseTime(List<AnalyticsData> data) {
        return data.stream()
            .mapToDouble(AnalyticsData::getMetricValue)
            .average()
            .orElse(0.0);
    }
    
    private Double calculatePeakResponseTime(List<AnalyticsData> data) {
        return data.stream()
            .mapToDouble(AnalyticsData::getMetricValue)
            .max()
            .orElse(0.0);
    }
    
    private Double calculateErrorRate(List<AnalyticsData> data) {
        long errorCount = data.stream()
            .filter(d -> d.getMetricValue() > 0)
            .count();
        
        return data.isEmpty() ? 0.0 : (double) errorCount / data.size() * 100;
    }
    
    private Double calculateThroughput(List<AnalyticsData> data) {
        return data.stream()
            .mapToDouble(AnalyticsData::getMetricValue)
            .sum();
    }
    
    private Double calculateUptime(List<AnalyticsData> data) {
        // Calculate uptime based on available data
        return 99.9; // Placeholder
    }
    
    private Long calculateCompletedWorkflows(List<AnalyticsData> data) {
        return data.stream()
            .filter(d -> d.getMetricValue() > 0)
            .count();
    }
    
    private Double calculateAverageCompletionTime(List<AnalyticsData> data) {
        return data.stream()
            .mapToDouble(AnalyticsData::getMetricValue)
            .average()
            .orElse(0.0);
    }
    
    private Double calculateWorkflowEfficiency(List<AnalyticsData> data) {
        // Calculate efficiency based on completion time vs expected time
        return 85.5; // Placeholder
    }
    
    private List<String> identifyWorkflowBottlenecks(List<AnalyticsData> data) {
        // Identify bottlenecks based on data analysis
        return List.of("Approval Step", "Review Process");
    }
    
    private Double calculateAverageSearchTime(List<AnalyticsData> data) {
        return data.stream()
            .mapToDouble(AnalyticsData::getMetricValue)
            .average()
            .orElse(0.0);
    }
    
    private List<String> getPopularSearchTerms(List<AnalyticsData> data) {
        // Extract popular search terms from metric data
        return List.of("contract", "agreement", "report");
    }
    
    private Double calculateSearchSuccessRate(List<AnalyticsData> data) {
        long successfulSearches = data.stream()
            .filter(d -> d.getMetricValue() > 0)
            .count();
        
        return data.isEmpty() ? 0.0 : (double) successfulSearches / data.size() * 100;
    }
    
    private Long calculateNoResultsSearches(List<AnalyticsData> data) {
        return data.stream()
            .filter(d -> d.getMetricValue() == 0)
            .count();
    }
    
    private Double calculateTotalStorageUsed(List<AnalyticsData> data) {
        return data.stream()
            .mapToDouble(AnalyticsData::getMetricValue)
            .sum();
    }
    
    private Double calculateStorageGrowthRate(List<AnalyticsData> data) {
        // Calculate growth rate based on historical data
        return 5.2; // Placeholder percentage
    }
    
    private Double calculateAverageFileSize(List<AnalyticsData> data) {
        return data.stream()
            .mapToDouble(AnalyticsData::getMetricValue)
            .average()
            .orElse(0.0);
    }
    
    private Map<String, Double> getStorageByType(List<AnalyticsData> data) {
        // Group storage by file type
        return Map.of(
            "Documents", 1024.5,
            "Images", 512.3,
            "Videos", 2048.7
        );
    }
    
    private List<String> getCleanupRecommendations(List<AnalyticsData> data) {
        return List.of(
            "Archive old documents",
            "Remove duplicate files",
            "Compress large files"
        );
    }
    
    private Long calculateFailedLoginAttempts(List<AnalyticsData> data) {
        return data.stream()
            .filter(d -> d.getMetricValue() > 0)
            .count();
    }
    
    private Long calculateSuspiciousActivities(List<AnalyticsData> data) {
        return data.stream()
            .filter(d -> d.getMetricValue() > 0)
            .count();
    }
    
    private List<String> getSecurityAlerts(List<AnalyticsData> data) {
        return List.of(
            "Multiple failed login attempts",
            "Unusual access patterns",
            "Suspicious file uploads"
        );
    }
    
    private Double calculateComplianceScore(List<AnalyticsData> data) {
        // Calculate compliance score based on security events
        return 92.5; // Placeholder
    }
    
    // Predictive analytics methods
    
    private Map<String, Object> predictUserActivityTrends() {
        return Map.of(
            "predictedActiveUsers", 150,
            "confidence", 0.85,
            "trend", "increasing"
        );
    }
    
    private Map<String, Object> predictStorageGrowth() {
        return Map.of(
            "predictedGrowthGB", 50.5,
            "confidence", 0.78,
            "timeframe", "30 days"
        );
    }
    
    private Map<String, Object> predictSystemLoad() {
        return Map.of(
            "predictedLoad", 75.2,
            "confidence", 0.82,
            "peakTime", "14:00"
        );
    }
    
    private Map<String, Object> predictDocumentUsagePatterns() {
        return Map.of(
            "predictedDownloads", 1250,
            "confidence", 0.88,
            "peakDay", "Tuesday"
        );
    }
    
    private Map<String, Object> predictWorkflowCompletionTimes() {
        return Map.of(
            "predictedAverageTime", 2.5,
            "confidence", 0.79,
            "unit", "hours"
        );
    }
}
