package com.bpdb.dms.service;

import com.bpdb.dms.entity.*;
import com.bpdb.dms.repository.SystemHealthCheckRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;

/**
 * Service for system health monitoring
 */
@Service
@Transactional
public class SystemHealthMonitoringService {
    
    private static final Logger logger = LoggerFactory.getLogger(SystemHealthMonitoringService.class);
    
    @Autowired
    private SystemHealthCheckRepository systemHealthCheckRepository;
    
    @Autowired
    private AuditService auditService;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * Create a new health check
     */
    public SystemHealthCheck createHealthCheck(String checkName, HealthCheckType checkType,
                                              String component, String service, String environment,
                                              Double thresholdValue, Integer checkIntervalSeconds) {
        try {
            SystemHealthCheck healthCheck = new SystemHealthCheck(checkName, checkType, HealthStatus.UNKNOWN, LocalDateTime.now());
            healthCheck.setComponent(component);
            healthCheck.setService(service);
            healthCheck.setEnvironment(environment);
            healthCheck.setThresholdValue(thresholdValue);
            healthCheck.setCheckIntervalSeconds(checkIntervalSeconds);
            healthCheck.setNextCheckAt(LocalDateTime.now().plusSeconds(checkIntervalSeconds));
            
            SystemHealthCheck savedCheck = systemHealthCheckRepository.save(healthCheck);
            
            auditService.logActivity("SYSTEM", "HEALTH_CHECK_CREATED", 
                "Health check created: " + checkName, null);
            
            logger.info("Health check created: {}", checkName);
            
            return savedCheck;
            
        } catch (Exception e) {
            logger.error("Failed to create health check: {}", e.getMessage());
            throw new RuntimeException("Failed to create health check", e);
        }
    }
    
    /**
     * Execute health check
     */
    @Async
    public CompletableFuture<SystemHealthCheck> executeHealthCheck(Long checkId) {
        try {
            SystemHealthCheck healthCheck = systemHealthCheckRepository.findById(checkId)
                .orElseThrow(() -> new RuntimeException("Health check not found"));
            
            logger.info("Executing health check: {}", healthCheck.getCheckName());
            
            long startTime = System.currentTimeMillis();
            
            // Perform the actual health check based on type
            HealthCheckResult result = performHealthCheck(healthCheck);
            
            long endTime = System.currentTimeMillis();
            long responseTime = endTime - startTime;
            
            // Update health check with results
            healthCheck.setStatus(result.getStatus());
            healthCheck.setResponseTimeMs(responseTime);
            healthCheck.setActualValue(result.getActualValue());
            healthCheck.setErrorMessage(result.getErrorMessage());
            healthCheck.setCheckData(result.getCheckData());
            healthCheck.setExecutedAt(LocalDateTime.now());
            healthCheck.setNextCheckAt(LocalDateTime.now().plusSeconds(healthCheck.getCheckIntervalSeconds()));
            
            // Determine severity based on status and threshold
            healthCheck.setSeverity(determineSeverity(healthCheck));
            
            // Reset retry count on success
            if (result.getStatus() == HealthStatus.HEALTHY) {
                healthCheck.setRetryCount(0);
            } else {
                healthCheck.setRetryCount(healthCheck.getRetryCount() + 1);
            }
            
            SystemHealthCheck savedCheck = systemHealthCheckRepository.save(healthCheck);
            
            // Send notification if critical
            if ("CRITICAL".equals(healthCheck.getSeverity())) {
                sendCriticalHealthAlert(healthCheck);
            }
            
            logger.info("Health check completed: {} - Status: {} - Response time: {}ms", 
                healthCheck.getCheckName(), healthCheck.getStatus(), responseTime);
            
            return CompletableFuture.completedFuture(savedCheck);
            
        } catch (Exception e) {
            logger.error("Failed to execute health check: {}", e.getMessage());
            return CompletableFuture.failedFuture(e);
        }
    }
    
    /**
     * Execute all due health checks
     */
    @Scheduled(fixedDelay = 60000) // Run every minute
    public void executeDueHealthChecks() {
        try {
            List<SystemHealthCheck> dueChecks = systemHealthCheckRepository.findHealthChecksDueForExecution(LocalDateTime.now());
            
            for (SystemHealthCheck check : dueChecks) {
                executeHealthCheck(check.getId());
            }
            
        } catch (Exception e) {
            logger.error("Failed to execute due health checks: {}", e.getMessage());
        }
    }
    
    /**
     * Retry failed health checks
     */
    @Scheduled(fixedDelay = 300000) // Run every 5 minutes
    public void retryFailedHealthChecks() {
        try {
            List<SystemHealthCheck> failedChecks = systemHealthCheckRepository.findFailedHealthChecks();
            
            for (SystemHealthCheck check : failedChecks) {
                executeHealthCheck(check.getId());
            }
            
        } catch (Exception e) {
            logger.error("Failed to retry failed health checks: {}", e.getMessage());
        }
    }
    
    /**
     * Get system health overview
     */
    public Map<String, Object> getSystemHealthOverview() {
        try {
            Map<String, Object> overview = new HashMap<>();
            
            // Get latest health checks by component
            List<SystemHealthCheck> latestChecks = systemHealthCheckRepository.findLatestHealthChecksByComponent();
            
            // Calculate overall health score
            double healthScore = calculateOverallHealthScore(latestChecks);
            overview.put("overallHealthScore", healthScore);
            
            // Get health status distribution
            Map<String, Long> statusDistribution = getHealthStatusDistribution(latestChecks);
            overview.put("statusDistribution", statusDistribution);
            
            // Get critical issues
            List<SystemHealthCheck> criticalIssues = latestChecks.stream()
                .filter(check -> "CRITICAL".equals(check.getSeverity()))
                .collect(java.util.stream.Collectors.toList());
            overview.put("criticalIssues", criticalIssues.size());
            
            // Get component health
            Map<String, Object> componentHealth = getComponentHealth(latestChecks);
            overview.put("componentHealth", componentHealth);
            
            // Get service health
            Map<String, Object> serviceHealth = getServiceHealth(latestChecks);
            overview.put("serviceHealth", serviceHealth);
            
            return overview;
            
        } catch (Exception e) {
            logger.error("Failed to get system health overview: {}", e.getMessage());
            throw new RuntimeException("Failed to get system health overview", e);
        }
    }
    
    /**
     * Get health check statistics
     */
    public Map<String, Object> getHealthCheckStatistics() {
        try {
            return Map.of(
                "totalChecks", systemHealthCheckRepository.count(),
                "healthyChecks", systemHealthCheckRepository.countByStatus(HealthStatus.HEALTHY),
                "warningChecks", systemHealthCheckRepository.countByStatus(HealthStatus.WARNING),
                "criticalChecks", systemHealthCheckRepository.countByStatus(HealthStatus.CRITICAL),
                "failedChecks", systemHealthCheckRepository.countByStatus(HealthStatus.FAILED),
                "enabledChecks", systemHealthCheckRepository.findByIsEnabledTrue().size()
            );
            
        } catch (Exception e) {
            logger.error("Failed to get health check statistics: {}", e.getMessage());
            throw new RuntimeException("Failed to get health check statistics", e);
        }
    }
    
    /**
     * Get health checks by criteria
     */
    public Page<SystemHealthCheck> getHealthChecks(HealthCheckType checkType, HealthStatus status,
                                                   String component, String service, String severity,
                                                   Pageable pageable) {
        return systemHealthCheckRepository.findByMultipleCriteria(checkType, status, component, service, severity, pageable);
    }
    
    /**
     * Get health check history
     */
    public List<SystemHealthCheck> getHealthCheckHistory(Long checkId, LocalDateTime startDate, LocalDateTime endDate) {
        return systemHealthCheckRepository.findByExecutedAtBetween(startDate, endDate)
            .stream()
            .filter(check -> check.getId().equals(checkId))
            .collect(java.util.stream.Collectors.toList());
    }
    
    /**
     * Perform the actual health check
     */
    private HealthCheckResult performHealthCheck(SystemHealthCheck healthCheck) {
        try {
            switch (healthCheck.getCheckType()) {
                case DATABASE_CONNECTION:
                    return checkDatabaseConnection(healthCheck);
                case REDIS_CONNECTION:
                    return checkRedisConnection(healthCheck);
                case ELASTICSEARCH_CONNECTION:
                    return checkElasticsearchConnection(healthCheck);
                case FILE_SYSTEM:
                    return checkFileSystem(healthCheck);
                case MEMORY_USAGE:
                    return checkMemoryUsage(healthCheck);
                case CPU_USAGE:
                    return checkCpuUsage(healthCheck);
                case DISK_SPACE:
                    return checkDiskSpace(healthCheck);
                case NETWORK_CONNECTIVITY:
                    return checkNetworkConnectivity(healthCheck);
                case API_RESPONSE_TIME:
                    return checkApiResponseTime(healthCheck);
                case SERVICE_AVAILABILITY:
                    return checkServiceAvailability(healthCheck);
                default:
                    return checkGenericHealth(healthCheck);
            }
            
        } catch (Exception e) {
            logger.error("Health check failed: {}", e.getMessage());
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check database connection
     */
    private HealthCheckResult checkDatabaseConnection(SystemHealthCheck healthCheck) {
        try {
            // Simulate database connection check
            Thread.sleep(100);
            
            // In production, this would actually test database connectivity
            boolean isConnected = true; // Simulated result
            
            if (isConnected) {
                return new HealthCheckResult(HealthStatus.HEALTHY, 1.0, null, "Database connection successful");
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, 0.0, "Database connection failed", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check Redis connection
     */
    private HealthCheckResult checkRedisConnection(SystemHealthCheck healthCheck) {
        try {
            // Simulate Redis connection check
            Thread.sleep(50);
            
            boolean isConnected = true; // Simulated result
            
            if (isConnected) {
                return new HealthCheckResult(HealthStatus.HEALTHY, 1.0, null, "Redis connection successful");
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, 0.0, "Redis connection failed", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check Elasticsearch connection
     */
    private HealthCheckResult checkElasticsearchConnection(SystemHealthCheck healthCheck) {
        try {
            // Simulate Elasticsearch connection check
            Thread.sleep(75);
            
            boolean isConnected = true; // Simulated result
            
            if (isConnected) {
                return new HealthCheckResult(HealthStatus.HEALTHY, 1.0, null, "Elasticsearch connection successful");
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, 0.0, "Elasticsearch connection failed", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check file system
     */
    private HealthCheckResult checkFileSystem(SystemHealthCheck healthCheck) {
        try {
            // Simulate file system check
            Thread.sleep(25);
            
            // In production, this would check disk space, permissions, etc.
            double diskUsage = 45.5; // Simulated disk usage percentage
            
            if (diskUsage < 80) {
                return new HealthCheckResult(HealthStatus.HEALTHY, diskUsage, null, "File system healthy");
            } else if (diskUsage < 90) {
                return new HealthCheckResult(HealthStatus.WARNING, diskUsage, "Disk usage high", null);
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, diskUsage, "Disk usage critical", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check memory usage
     */
    private HealthCheckResult checkMemoryUsage(SystemHealthCheck healthCheck) {
        try {
            // Simulate memory usage check
            Thread.sleep(30);
            
            Runtime runtime = Runtime.getRuntime();
            long totalMemory = runtime.totalMemory();
            long freeMemory = runtime.freeMemory();
            long usedMemory = totalMemory - freeMemory;
            double memoryUsage = (double) usedMemory / totalMemory * 100;
            
            if (memoryUsage < 80) {
                return new HealthCheckResult(HealthStatus.HEALTHY, memoryUsage, null, "Memory usage normal");
            } else if (memoryUsage < 90) {
                return new HealthCheckResult(HealthStatus.WARNING, memoryUsage, "Memory usage high", null);
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, memoryUsage, "Memory usage critical", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check CPU usage
     */
    private HealthCheckResult checkCpuUsage(SystemHealthCheck healthCheck) {
        try {
            // Simulate CPU usage check
            Thread.sleep(20);
            
            double cpuUsage = 25.5; // Simulated CPU usage percentage
            
            if (cpuUsage < 70) {
                return new HealthCheckResult(HealthStatus.HEALTHY, cpuUsage, null, "CPU usage normal");
            } else if (cpuUsage < 85) {
                return new HealthCheckResult(HealthStatus.WARNING, cpuUsage, "CPU usage high", null);
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, cpuUsage, "CPU usage critical", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check disk space
     */
    private HealthCheckResult checkDiskSpace(SystemHealthCheck healthCheck) {
        try {
            // Simulate disk space check
            Thread.sleep(40);
            
            double diskSpace = 35.2; // Simulated disk space usage percentage
            
            if (diskSpace < 80) {
                return new HealthCheckResult(HealthStatus.HEALTHY, diskSpace, null, "Disk space sufficient");
            } else if (diskSpace < 90) {
                return new HealthCheckResult(HealthStatus.WARNING, diskSpace, "Disk space low", null);
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, diskSpace, "Disk space critical", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check network connectivity
     */
    private HealthCheckResult checkNetworkConnectivity(SystemHealthCheck healthCheck) {
        try {
            // Simulate network connectivity check
            Thread.sleep(100);
            
            boolean isConnected = true; // Simulated result
            
            if (isConnected) {
                return new HealthCheckResult(HealthStatus.HEALTHY, 1.0, null, "Network connectivity OK");
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, 0.0, "Network connectivity failed", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check API response time
     */
    private HealthCheckResult checkApiResponseTime(SystemHealthCheck healthCheck) {
        try {
            // Simulate API response time check
            Thread.sleep(200);
            
            double responseTime = 150.5; // Simulated response time in ms
            
            if (responseTime < 500) {
                return new HealthCheckResult(HealthStatus.HEALTHY, responseTime, null, "API response time good");
            } else if (responseTime < 1000) {
                return new HealthCheckResult(HealthStatus.WARNING, responseTime, "API response time slow", null);
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, responseTime, "API response time critical", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check service availability
     */
    private HealthCheckResult checkServiceAvailability(SystemHealthCheck healthCheck) {
        try {
            // Simulate service availability check
            Thread.sleep(80);
            
            boolean isAvailable = true; // Simulated result
            
            if (isAvailable) {
                return new HealthCheckResult(HealthStatus.HEALTHY, 1.0, null, "Service available");
            } else {
                return new HealthCheckResult(HealthStatus.CRITICAL, 0.0, "Service unavailable", null);
            }
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Check generic health
     */
    private HealthCheckResult checkGenericHealth(SystemHealthCheck healthCheck) {
        try {
            // Simulate generic health check
            Thread.sleep(50);
            
            return new HealthCheckResult(HealthStatus.HEALTHY, 1.0, null, "Generic health check passed");
            
        } catch (Exception e) {
            return new HealthCheckResult(HealthStatus.FAILED, 0.0, e.getMessage(), null);
        }
    }
    
    /**
     * Determine severity based on status and threshold
     */
    private String determineSeverity(SystemHealthCheck healthCheck) {
        if (healthCheck.getStatus() == HealthStatus.CRITICAL) {
            return "CRITICAL";
        } else if (healthCheck.getStatus() == HealthStatus.WARNING) {
            return "HIGH";
        } else if (healthCheck.getStatus() == HealthStatus.FAILED) {
            return "CRITICAL";
        } else if (healthCheck.getThresholdValue() != null && healthCheck.getActualValue() != null) {
            if (healthCheck.getActualValue() > healthCheck.getThresholdValue() * 0.9) {
                return "MEDIUM";
            }
        }
        
        return "LOW";
    }
    
    /**
     * Send critical health alert
     */
    private void sendCriticalHealthAlert(SystemHealthCheck healthCheck) {
        try {
            notificationService.createNotification(
                null, // System notification
                "Critical Health Alert",
                "Critical health issue detected: " + healthCheck.getCheckName() + " - " + healthCheck.getErrorMessage(),
                NotificationType.SYSTEM_ALERT,
                NotificationPriority.CRITICAL
            );
            
        } catch (Exception e) {
            logger.error("Failed to send critical health alert: {}", e.getMessage());
        }
    }
    
    /**
     * Calculate overall health score
     */
    private double calculateOverallHealthScore(List<SystemHealthCheck> checks) {
        if (checks.isEmpty()) {
            return 100.0;
        }
        
        long healthyCount = checks.stream()
            .filter(check -> check.getStatus() == HealthStatus.HEALTHY)
            .count();
        
        return (double) healthyCount / checks.size() * 100;
    }
    
    /**
     * Get health status distribution
     */
    private Map<String, Long> getHealthStatusDistribution(List<SystemHealthCheck> checks) {
        return checks.stream()
            .collect(java.util.stream.Collectors.groupingBy(
                check -> check.getStatus().name(),
                java.util.stream.Collectors.counting()
            ));
    }
    
    /**
     * Get component health
     */
    private Map<String, Object> getComponentHealth(List<SystemHealthCheck> checks) {
        Map<String, Object> componentHealth = new HashMap<>();
        
        Map<String, List<SystemHealthCheck>> componentGroups = checks.stream()
            .collect(java.util.stream.Collectors.groupingBy(SystemHealthCheck::getComponent));
        
        for (Map.Entry<String, List<SystemHealthCheck>> entry : componentGroups.entrySet()) {
            String component = entry.getKey();
            List<SystemHealthCheck> componentChecks = entry.getValue();
            
            long healthyCount = componentChecks.stream()
                .filter(check -> check.getStatus() == HealthStatus.HEALTHY)
                .count();
            
            double healthScore = componentChecks.isEmpty() ? 100.0 : 
                (double) healthyCount / componentChecks.size() * 100;
            
            componentHealth.put(component, Map.of(
                "healthScore", healthScore,
                "totalChecks", componentChecks.size(),
                "healthyChecks", healthyCount
            ));
        }
        
        return componentHealth;
    }
    
    /**
     * Get service health
     */
    private Map<String, Object> getServiceHealth(List<SystemHealthCheck> checks) {
        Map<String, Object> serviceHealth = new HashMap<>();
        
        Map<String, List<SystemHealthCheck>> serviceGroups = checks.stream()
            .collect(java.util.stream.Collectors.groupingBy(SystemHealthCheck::getService));
        
        for (Map.Entry<String, List<SystemHealthCheck>> entry : serviceGroups.entrySet()) {
            String service = entry.getKey();
            List<SystemHealthCheck> serviceChecks = entry.getValue();
            
            long healthyCount = serviceChecks.stream()
                .filter(check -> check.getStatus() == HealthStatus.HEALTHY)
                .count();
            
            double healthScore = serviceChecks.isEmpty() ? 100.0 : 
                (double) healthyCount / serviceChecks.size() * 100;
            
            serviceHealth.put(service, Map.of(
                "healthScore", healthScore,
                "totalChecks", serviceChecks.size(),
                "healthyChecks", healthyCount
            ));
        }
        
        return serviceHealth;
    }
    
    /**
     * Health check result class
     */
    private static class HealthCheckResult {
        private final HealthStatus status;
        private final Double actualValue;
        private final String errorMessage;
        private final String checkData;
        
        public HealthCheckResult(HealthStatus status, Double actualValue, String errorMessage, String checkData) {
            this.status = status;
            this.actualValue = actualValue;
            this.errorMessage = errorMessage;
            this.checkData = checkData;
        }
        
        public HealthStatus getStatus() { return status; }
        public Double getActualValue() { return actualValue; }
        public String getErrorMessage() { return errorMessage; }
        public String getCheckData() { return checkData; }
    }
}
